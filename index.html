<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Solitaire</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body
    class="mx-auto max-w-6xl bg-[radial-gradient(circle_at_bottom_left,_var(--tw-gradient-stops))] from-purple-600 to-blue-600">
    <div class="container flex justify-center mx-auto">
      <h1 class="text-5xl pt-2 text-white">Welcome to Solitaire!</h1>

      <div class="pl-5 pt-3">
        <button
          id="play"
          class="border border-black rounded px-6 py-2 text-lg font-bold bg-black text-white"
          onclick="startGame()">
          New Game
        </button>
        <button
          id="reshuffle"
          class="border border-black rounded px-6 py-2 text-lg font-bold bg-black text-white invisible"
          onclick="startGame()">
          Reshuffle
        </button>
      </div>
      <div class="pl-6">
        <div>
          <p class="text-lg text-white">Timer: <span id="timer"> </span></p>
        </div>
        <div>
          <p class="text-lg text-white">
            Move Counter: <span id="moveCounter"> </span>
          </p>
        </div>
      </div>
    </div>
    <div class="container flex justify-center mx-auto">
      <div class="pt-2 flex justify-start gap-1 pl-5">
        <div id="deck" class="w-[150px] h-[200px] pl-2"></div>
        <div
          id="pile"
          class="rounded border border-black pile flex justify-start w-[150px] h-[200px] pl-2"></div>
        <div id="pile-2" class="w-[150px] h-[200px] pl-2"></div>
        <div id="pile-3" class="w-[150px] h-[200px] pl-2"></div>
      </div>
      <div class="pl-20 pt-2 flex justify-end gap-1">
        <div
          id="foundation-1"
          class="rounded border border-black w-[150px] h-[200px] pl-2"></div>
        <div
          id="foundation-2"
          class="rounded border border-black w-[150px] h-[200px] pl-2"></div>
        <div
          id="foundation-3"
          class="rounded border border-black w-[150px] h-[200px] pl-2"></div>
        <div
          id="foundation-4"
          class="rounded border border-black w-[150px] h-[200px] pl-2"></div>
      </div>
    </div>
    <div id="tableau" class="pt-2 flex gap-1 column">
    </div>
    <style>
      .highlight {
        box-shadow: 0 0 10px 2px yellow;
      }
    </style>

    <script>
      let deckId;
      let cards = [];
      let remainingCards = [];
      let stockPile = [];
      let wastePile = [];
      let piles = Array(7)
        .fill(null)
        .map(() => []);

      let foundationPiles = Array(4)
        .fill(null)
        .map(() => []);

      let selectedCard = null; // Add selectedCard variable

      // Timer variables
      let startTime;
      let timerInterval;

      // Move counter variables
      let moveCount = 0;

      // Function to start the timer
      function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
      }

      // Function to update the timer
      function updateTimer() {
        let elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        let minutes = Math.floor(elapsedTime / 60);
        let seconds = elapsedTime % 60;
        document.getElementById("timer").textContent =
          minutes + "m " + seconds + "s";
      }

      // Function to increment the move counter
      function incrementMoveCounter() {
        moveCount++;
        document.getElementById("moveCounter").textContent = moveCount;
      }

      // Function to reset the move counter
      function resetMoveCounter() {
        moveCount = 0;
        document.getElementById("moveCounter").textContent = moveCount;
      }
      async function startGame() {
        reshuffle.classList.remove("invisible");
        selectedCard = null;
        piles = Array(7)
          .fill(null)
          .map(() => []);
        pile.innerHTML = "";
        pile.imagesHTML = "";
        await createDeck();
        startTimer();
        resetMoveCounter();
      }
      async function createDeck() {
        try {
          const response = await fetch(
            "https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1"
          );
          const data = await response.json();
          deckId = data.deck_id;
          await drawCards(28);
          distributeCardsToPiles(cards);
          await drawRemainingCards(data.remaining);
          displayStockPile();
        } catch (error) {
          console.log("Error Creating Deck", error);
        }
      }

      function distributeCardsToPiles(cards) {
        let cardIndex = 0;
        for (let pileIndex = 0; pileIndex < 7; pileIndex++) {
          for (let j = 0; j <= pileIndex; j++) {
            piles[pileIndex].push(cards[cardIndex++]);
          }
        }
// Clear the foundation piles
foundationPiles = [[], [], [], []];

// Clear the foundation piles in the UI
for(let i = 1; i <= 4; i++) {
    const foundationPileElement = document.getElementById(`foundation-${i}`);
    foundationPileElement.innerHTML = "";
}
        displayPiles();
      }

      function displayPiles() {
        const tableau = document.getElementById("tableau");
        tableau.innerHTML = "";

        for (let pile of piles) {
          const pileDiv = document.createElement("div");
          pileDiv.classList.add("pileDiv");

          // Display all cards but the last one as face down
          for (let i = 0; i < pile.length - 1; i++) {
            const cardElement = createCardElement(pile[i].code, true, playCard); // face-down
            pileDiv.appendChild(cardElement);
          }

          // Display the last card as face up
          if (pile.length > 0) {
            const cardElement = createCardElement(
              pile[pile.length - 1].code,
              false,
              playCard
            ); // face-up
            pileDiv.appendChild(cardElement);
          }

          tableau.appendChild(pileDiv);
        }
      }

      async function drawRemainingCards(remainingCards) {
        try {
          const response = await fetch(
            `https://deckofcardsapi.com/api/deck/${deckId}/draw/?count=${remainingCards}`
          );
          const data = await response.json();
          stockPile = data.cards.map((card) => ({
            value: card.value,
            suit: card.suit,
            code: card.code,
            img: card.image,
          }));
        } catch (error) {
          console.log("Error drawing remaining cards:", error);
        }
      }

      function displayStockPile() {
        const deck = document.getElementById("deck");
        if (stockPile.length > 0) {
          deck.innerHTML = `<img src="src/back.png" alt="Card Back">`;
          deck.onclick = talonPileDraw;
        } else {
          deck.innerHTML = `<img src="src/reload.png" alt="Card Back">`;
          deck.onclick = resetStockPile;
        }
      }

      // After the definition of displayStockPile()
      function resetStockPile() {
        // Move cards from wastePile to stockPile
        while (wastePile.length > 0) {
          stockPile.push(wastePile.pop());
        }

        // Clear the waste pile display
        const pile = document.querySelector(".pile");
        pile.innerHTML = "";

        // Update the stock pile display
        displayStockPile();
      }

      function talonPileDraw() {
        for (let i = 0; i < 3 && stockPile.length > 0; i++) {
          wastePile.push(stockPile.pop());
        }
        incrementMoveCounter();
        displayWastePile();
        displayStockPile();
      }
      function displayWastePile() {
        const pile = document.querySelector(".pile");

        if (wastePile.length > 0) {
          let imagesHTML = "";
          const numImages = Math.min(wastePile.length, 3); // Display up to 3 images

          for (
            let i = wastePile.length - numImages;
            i < wastePile.length;
            i++
          ) {
            const card = wastePile[i];
            imagesHTML += `<img src="${card.img}" alt="${card.code}" onclick="playCardFromWastePile(event, ${i})">`;
          }

          pile.innerHTML = imagesHTML;
        } else {
          pile.innerHTML = "";
        }
      }

      function playCardFromWastePile(event, cardIndex) {
        
        console.log("called");
        const clickedCardElement = event.target;
        const clickedCardCode = clickedCardElement.getAttribute("alt");

        console.log("cardindex" + cardIndex);
        console.log("wastepile length" + wastePile.length);
        // if (cardIndex === wastePile.length - 1) {
        console.log(selectedCard);
        const cardObject = wastePile[cardIndex];

        selectedCard = {
          card: cardObject,
          cardIndex: cardIndex,
          pileIndex: -1, // -1 means the card is from the waste pile
          element: clickedCardElement,
        };
        clickedCardElement.classList.add("highlight");

        console.log(selectedCard);
        //}
      }

      async function shuffleDeck() {
        let response = await fetch(
          "https://deckofcardsapi.com/api/deck/new/shuffle/?deck_count=1&remaining=true"
        );
        let data = await response.json();

        let drawResponse = await fetch(
          `https://deckofcardsapi.com/api/deck/${data.deck_id}/draw/?count=${remainingCards}`
        );
        let drawData = await drawResponse.json();

        console.log("Deck of Cards:", cards);
      }

      async function drawCards(count) {
        try {
          const response = await fetch(
            `https://deckofcardsapi.com/api/deck/${deckId}/draw/?count=${count}`
          );
          const data = await response.json();
          cards = data.cards.map((card) => ({
            value: card.value,
            suit: card.suit,
            code: card.code,
            img: card.image,
          }));
          remainingCards = data.remaining;
          console.log(remainingCards, "cards remaining in the deck");
          console.log("Deck of Cards:", cards);
        } catch (error) {
          console.log("Error drawing cards:", error);
        }
      }

      function createCardElement(cardValue, isFaceDown, clickHandler) {
        const cardElement = document.createElement("img");
        cardElement.setAttribute("data-value", cardValue);
        cardElement.onclick = clickHandler;
        if (isFaceDown) {
          cardElement.setAttribute("src", "src/back.png");
          cardElement.classList.add("down");
        } else {
          cardElement.setAttribute(
            "src",
            `https://deckofcardsapi.com/static/img/${cardValue}.png`
          );
          cardElement.classList.remove("down");
        }
        return cardElement;
      }

      function parseCardCode(cardCode) {
        let code = cardCode.slice(0, -1);
        const suitCode = cardCode[cardCode.length - 1];
        let suit;

        // Handle the face cards and the Ace
        switch (code) {
          case "J":
            code = "11";
            break;
          case "Q":
            code = "12";
            break;
          case "K":
            code = "13";
            break;
          case "A":
            code = "1";
            break;
          case "0":
            code = "10";
            break;
          default:
            break;
        }

        switch (suitCode) {
          case "S":
            suit = "SPADES";
            break;
          case "C":
            suit = "CLUBS";
            break;
          case "H":
            suit = "HEARTS";
            break;
          case "D":
            suit = "DIAMONDS";
            break;
          default:
            throw new Error(`Invalid suit code: ${suitCode}`);
        }

        return { suit, code };
      }

      function getCardColor(suit) {
        switch (suit) {
          case "HEARTS":
          case "DIAMONDS":
            return "red";
          case "SPADES":
          case "CLUBS":
            return "black";
          default:
            throw new Error(`Invalid suit: ${suit}`);
        }
      }

      // function playCard(event) {
      //   const clickedCardElement = event.target;
      //   const clickedCardCode = clickedCardElement.getAttribute("data-value");
      //   const clickedPileIndex = Array.from(
      //     clickedCardElement.parentNode.parentNode.children
      //   ).indexOf(clickedCardElement.parentNode);
      //   const clickedCardIndex = Array.from(
      //     clickedCardElement.parentNode.children
      //   ).indexOf(clickedCardElement);

      //   if (selectedCard) {
      //     const selectedCardInfo = parseCardCode(selectedCard.card.code);
      //     const clickedCardInfo = parseCardCode(clickedCardCode);

      //     const selectedCardColor = getCardColor(selectedCardInfo.suit);
      //     const clickedCardColor = getCardColor(clickedCardInfo.suit);

      //     if (
      //       selectedCardColor !== clickedCardColor &&
      //       parseInt(selectedCardInfo.code) ===
      //         parseInt(clickedCardInfo.code) - 1
      //     ) {
      //       let movedCards = piles[selectedCard.pileIndex].splice(
      //         selectedCard.cardIndex
      //       );
      //       piles[clickedPileIndex] =
      //         piles[clickedPileIndex].concat(movedCards);
      //       incrementMoveCounter();
      //       selectedCard.element.classList.remove("highlight");
      //       selectedCard = null;

      //       displayPiles();
      //     } else {
      //       selectedCard.element.classList.remove("highlight");
      //       selectedCard = null;
      //     }
      //   } else {
      //     const cardObject = piles[clickedPileIndex][clickedCardIndex];

      //     if (clickedCardIndex === piles[clickedPileIndex].length - 1) {
      //       selectedCard = {
      //         card: cardObject,
      //         cardIndex: clickedCardIndex,
      //         pileIndex: clickedPileIndex,
      //         element: clickedCardElement,
      //       };
      //       clickedCardElement.classList.add("highlight");
      //     }
      //   }
      // }

      function playCard(event) {
  const clickedCardElement = event.target;
  const clickedCardCode = clickedCardElement.getAttribute("data-value");
  const clickedPileIndex = Array.from(
    clickedCardElement.parentNode.parentNode.children
  ).indexOf(clickedCardElement.parentNode);
  const clickedCardIndex = Array.from(
    clickedCardElement.parentNode.children
  ).indexOf(clickedCardElement);

  if (selectedCard) {
    const selectedCardInfo = parseCardCode(selectedCard.card.code);
    const clickedCardInfo = parseCardCode(clickedCardCode);

    const selectedCardColor = getCardColor(selectedCardInfo.suit);
    const clickedCardColor = getCardColor(clickedCardInfo.suit);

    if (
      selectedCardColor !== clickedCardColor &&
      parseInt(selectedCardInfo.code) ===
        parseInt(clickedCardInfo.code) - 1
    ) {
      let movedCards;
      if (selectedCard.pileIndex === -1) { // The card is from the waste pile
        movedCards = wastePile.splice(selectedCard.cardIndex, 1);
      } else {
        movedCards = piles[selectedCard.pileIndex].splice(
          selectedCard.cardIndex
        );
      }

      piles[clickedPileIndex] = piles[clickedPileIndex].concat(movedCards);

      incrementMoveCounter();
      selectedCard.element.classList.remove("highlight");
      selectedCard = null;

      displayPiles();
      displayWastePile();
    } else {
      selectedCard.element.classList.remove("highlight");
      selectedCard = null;
    }
  } else {
    const cardObject = piles[clickedPileIndex][clickedCardIndex];

    if (clickedCardIndex === piles[clickedPileIndex].length - 1) {
      selectedCard = {
        card: cardObject,
        cardIndex: clickedCardIndex,
        pileIndex: clickedPileIndex,
        element: clickedCardElement,
      };
      clickedCardElement.classList.add("highlight");
    }
  }
}



      // Add onclick events to the foundation piles
      document.getElementById("foundation-1").onclick = moveCardToFoundation;
      document.getElementById("foundation-2").onclick = moveCardToFoundation;
      document.getElementById("foundation-3").onclick = moveCardToFoundation;
      document.getElementById("foundation-4").onclick = moveCardToFoundation;

      function moveCardToFoundation(event) {
        console.log("Foundation pile was clicked: " + event.target.id);

        let foundationPileElement;

        // Check if the clicked element is a card
        if (event.target.classList.contains("card")) {
          // The clicked element is a card, so get its parent foundation pile
          foundationPileElement = event.target.parentNode;
        } else {
          // The clicked element is the foundation pile itself
          foundationPileElement = event.target;
        }
        foundationPileElement = event.target;
        const foundationPileIndex = Array.from(
          foundationPileElement.parentNode.children
        ).indexOf(foundationPileElement);

        if (selectedCard) {
          const selectedCardInfo = parseCardCode(selectedCard.card.code);

          let foundationPile = foundationPiles[foundationPileIndex];
          if (foundationPile.length > 0) {
            const topFoundationCardInfo = parseCardCode(
              foundationPile[foundationPile.length - 1].code
            );

            // Verify that the selected card can be moved to this foundation pile
            if (
              selectedCardInfo.suit === topFoundationCardInfo.suit &&
              parseInt(selectedCardInfo.code) ===
                parseInt(topFoundationCardInfo.code) + 1
            ) {
              let movedCards = piles[selectedCard.pileIndex].splice(
                selectedCard.cardIndex
              );
              foundationPiles[foundationPileIndex] =
                foundationPiles[foundationPileIndex].concat(movedCards);
              incrementMoveCounter();
              selectedCard.element.classList.remove("highlight");
              selectedCard = null;

              displayPiles();
              displayFoundationPiles();
            } else {
              selectedCard.element.classList.remove("highlight");
              selectedCard = null;
            }
          } else {
            // If the foundation pile is empty, only an Ace can be placed
            if (selectedCardInfo.code === "1") {
              let movedCards = piles[selectedCard.pileIndex].splice(
                selectedCard.cardIndex
              );
              foundationPiles[foundationPileIndex] =
                foundationPiles[foundationPileIndex].concat(movedCards);
              incrementMoveCounter();
              selectedCard.element.classList.remove("highlight");
              selectedCard = null;

              displayPiles();
              displayFoundationPiles();
            } else {
              selectedCard.element.classList.remove("highlight");
              selectedCard = null;
            }
          }
        }
      }

      // Function to be called when a foundation pile is clicked
      function onFoundationPileClick(event) {
        console.log("Foundation pile was clicked: " + event.target.id);
      }

      //   function addFoundationPileHandlers() {
      //   for (let i = 1; i <= 4; i++) {
      //     const foundationPileElement = document.getElementById(`foundation-${i}`);
      //     foundationPileElement.onclick = function () {
      //       if (!selectedCard) return; // No card selected, so ignore the click

      //       // Try to add the card to the foundation pile
      //       if (addCardToFoundationPile(i - 1, selectedCard.card)) {
      //         // Remove the card from its original pile
      //         piles[selectedCard.pileIndex].splice(selectedCard.cardIndex, 1);

      //         // Clear selectedCard and update the display
      //         selectedCard = null;
      //         displayPiles();
      //         displayFoundationPiles();
      //       }
      //     };
      //   }
      // }

      // function addCardToFoundationPile(pileIndex, card) {
      //   const foundationPile = foundationPiles[pileIndex];

      //   // Get the card info
      //   const cardInfo = parseCardCode(card.code);

      //   if (foundationPile.length === 0) {
      //     // The pile is empty. Only an Ace can be placed.
      //     if (cardInfo.code === "1") {
      //       foundationPile.push(card);
      //       return true;
      //     }
      //   } else {
      //     // The pile is not empty. The card must be the same suit as the top card, and one greater in value.
      //     const topCardInfo = parseCardCode(foundationPile[foundationPile.length - 1].code);
      //     if (topCardInfo.suit === cardInfo.suit && parseInt(topCardInfo.code) + 1 === parseInt(cardInfo.code)) {
      //       foundationPile.push(card);
      //       return true;
      //     }
      //   }

      //   return false;
      // }

      function displayFoundationPiles() {
        for (let i = 0; i < foundationPiles.length; i++) {
          const foundationPile = foundationPiles[i];
          const foundationPileElement = document.getElementById(
            `foundation-${i + 1}`
          );

          // Clear the current cards in the foundation pile
          foundationPileElement.innerHTML = "";

          // Display the top card in the pile
          if (foundationPile.length > 0) {
            const topCard = foundationPile[foundationPile.length - 1];
            const cardElement = createCardElement(topCard.code, false, null);
            foundationPileElement.appendChild(cardElement);
          }
        }
      }
    </script>
  </body>
</html>
